#include <string>
#include <vector>
#include <iostream>
#include <math.h>

using namespace std;
//////////////////////////////////////////////////////////////////
/////이렇게 풀면 가능하지만, 효율성 테스트에서 시간초과로 실패////
//////////////////////////////////////////////////////////////////
//int solution(int n) {
//    int answer = n - 1;
//    int index = 0;
//
//    for (int i = 2; i <= n; i++) {
//        for (int j = 1; j <= sqrt(i); j++) {
//            if (j != 1 && j != i && i%j == 0) {
//                index++;
//                break;
//            }
//        }
//    }
//
//    return answer - index;
//}
///////////////////////////////////////////////////////////////////////////
////////구글검색 결과 에라토스테네의 체 : 시간복잡도가 작은 알고리즘 존재//
///////////////////////////////////////////////////////////////////////////
// 2부터 시작해서 2의배수 제거 그다음 소수 3을 찾아 3의 배수 제거하는 방식/
///////////////////////////////////////////////////////////////////////////
int solution(int n) {
    int answer = 0;
    //소수면 0, 소수가 아니면 1로 바꾸는 배열
    bool temp[1000000] = { 0 };
    for (int i = 2; i <= n; i++) {
        //소수인지 확인
        //어떤 수의 배수였다면 소수가 아니므로 패스
        if (temp[i])
            continue;
        //위의 조건을 건너왔다면 소수가 아니므로 카운트 증가
        answer++;
        //현재수의 배수부터 N까지 자신의 배수는 소수가 아닌것으로 변환
        for (int j = i + i; j <= n; j += i) {
            temp[j] = true;
        }
        //이런식으로 배수를 true로 변경하면 반복문의 갯수를 줄일수잇음
    }
    return answer;
}

int main()
{
    int answer;

    answer = solution(10);
    cout << answer << endl;
    return 0;
}

//소수 찾기
//문제 설명
//1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.
//
//소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.
//(1은 소수가 아닙니다.)
//
//제한 조건
//n은 2이상 1000000이하의 자연수입니다.
//입출력 예
//n	result
//10	4
//5	3
//입출력 예 설명
//입출력 예 #1
//1부터 10 사이의 소수는[2, 3, 5, 7] 4개가 존재하므로 4를 반환
//
//입출력 예 #2
//1부터 5 사이의 소수는[2, 3, 5] 3개가 존재하므로 3를 반환